# MSA 구조로 전환을 위한 서비스 분리 및 트랜잭션 처리 방안 설계

----

## 목차

* [서론](#서론)

* [모놀리식 vs MSA](#모놀리식-vs-msa)
  * [모놀리식 아키텍처](#모놀리식-아키텍처)
  * [MSA (Micro Service Architecture)](#msa-micro-service-architecture)

* [현재 모놀리식 구조에서 도메인 간 결합된 기능](#현재-모놀리식-구조에서-도메인-간-결합된-기능)
  * [주문 기능](#주문-기능)
  * [결제 기능](#결제-기능)

* [MSA 구조로 도메인 분리](#MSA-구조로-도메인-분리)
  * [도메인 분리 및 담당 업무](#도메인-분리-및-담당-업무)

* [트랜잭션을 분리할 기능 분석](#트랜잭션을-분리할-기능-분석)
  * [트랜잭션이란](#트랜잭션이란)
  * [주문 기능](#주문-기능-1)
  * [결제 기능](#결제-기능-1)

* [해결 방안](#해결-방안)
  * [SAGA 패턴](#saga-패턴)
  * [각 기능에 대해 SAGA 패턴 적용 비교](#각-기능에-대해-saga-패턴-적용-비교)
  * [주문 기능 Orchestration 방식 적용](#주문-기능-orchestration-방식-적용)
  * [주문 기능 Choreography 방식 적용](#주문-기능-choreography-방식-적용)
  * [결제 기능 Orchestration 방식 적용](#결제-기능-orchestration-방식-적용)
  * [결제 기능 Choreography 방식 적용](#결제-기능-choreography-방식-적용)

* [결론](#결론)

* [출처](#출처)

--- 


## 서론
서비스의 규모가 확장됨에 따라 모놀리식 아키텍처에서 MSA 구조로 전환을 위해 도메인 별로 배포 단위를 분리한다면 그 분리에 따른 트랜잭션 처리의 한계와 해결 방안에 대해 고려해본다.

## 모놀리식 vs MSA
모놀리식 아키텍처
- 소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어 있는 형태이다.
- 모든 프로세스가 긴밀하게 결합되고 단일 서비스로 실행된다.

장점
- 소규모 프로젝트에서는 합리적이다.
- 개빌, 빌드, 배포가 용이하다.

단점 
- 애플리케이션 구동 시간이 늘어나고 빌드, 배포 시간이 길어진다.
- 많은 양의 코드가 몰려 있어 유지보수가 힘들다.
- 일부분의 오류가 전체에 영향을 미친다.

 MSA (Micro Service Architecture)
- 하나의 큰 애플리케이션을 여러 개의 작은 서비스 유닛으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처이다. 
- 각 마이크로 서비스는 상호 통신이 가능하며 이를 통해 전체 서비스를 구성한다.

장점 
- 독립적인 서비스로 배포가 빠르고 모놀리식보다 가볍다.
- 서비스별 개별 배포 가능하여 배포 시 전체 서비스의 중단이 없다. 
- 분리된 서비스로 개발할 수 있기 떄문에 서비스마다 가장 적합한 기술을 선택할 수 있다.

단점
- 서비스가 분산되어 있어 트랜잭션 관리, 장애 추적 및 테스트가 쉽지 않다.
- 서비스마다 DB가 분리되어 있어 데이터의 조회가 어렵고 데이터의 중복이 발생한다. 

## 현재 모놀리식 구조에서 도메인 간 결합된 기능
### **주문** 기능
현재의 모놀리식 구조
````
주문 TX() {
    상품_조회();
    상품_재고_차감();
    주문_생성();
    외부_플랫폼_데이터_전송();
}
````
결합된 도메인
* 상품
* 주문
* 외부 플랫폼

현재 구조에서의 문제점 : 상품 재고 차감, 주문 생성과 같은 메인 로직이 외부 데이터 플랫폼 데이터 전송과 같은 부가 로직과 하나의 트랜잭션에 묶여있어 외부 플랫폼 전송이 실패하면 전체가 롤백되는 현상이 발생한다.

### **결제** 기능
  현재의 모놀리식 구조
```
결제 TX() {
    주문_조회();
    쿠폰_사용();
    결제_생성();
    포인트_차감();
    주문_상태_변경();
}
```
결합된 도메인
* 주문
* 쿠폰
* 결제
* 포인트

## MSA로 구조로 도메인 분리
### 도메인 분리 및 담당 업무
* `유저`, `포인트` : 
  * 유저 정보를 조회한다.
  * 유저의 포인트 정보를 조회한다.
  * 유저의 포인트를 충전한다.
  * 유저의 포인트를 차감한다.
* `상품`, `재고`
  * 상품을 조회한다.
  * 상품 재고를 차감한다.
* `쿠폰`
  * 쿠폰을 발행한다.
  * 쿠폰을 사용한다.
* `주문`
  * 주문 데이터를 생성한다.
  * 외부 데이터 플랫폼에 데이터를 전송한다.
* `결제`
  * 결제 데이터를 생성한다.

## 트랜잭션을 분리할 기능 분석

<details>
<summary>트랜잭션이란?</summary>

### 트랜잭션
트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

### 트랜잭션 ACID 성질
* Atomicity (원자성)
    * 모든 작업이 하나의 단위로 실행되어야 한다.
    * 트랜잭션에 포함된 작업이 모두 성공하거나, 하나라도 실패하면 전체가 롤백되어 아무것도 실행되지 않은 상태가 되어야 한다.
* Consistency (일관성)
    * 트랜잭션이 실행된 후에도 데이터베이스의 상태가 일관성을 유지해야 한다.
* Isolation (격리성)
    * 동시에 여러 트랜잭션이 실행되더라도 각 트랜잭션은 서로 간섭받지 않고 독립적으로 실행되어야 한다.
* Durability (지속성)
    * 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 반영되어야 한다.

</details>

### 트랜잭션 분리할 기능 분석
* **주문 기능** 
````
상품 재고 차감 TX() {
    상품 조회();
    상품 재고 차감();
}

주문 데이터 생성 TX() {
    주문 데이터 생성();
}

데이터 플랫폼 전송 TX() {
    데이터 플랫폼 전송();
}
````
발생할 수 있는 문제점 </br>
재고 차감 후 주문 생성 실패 : 재고는 차감되었는데 주문이 생성되지 않아 데이터 정합성의 불일치가 발생한다.

* **결제 기능**
````
쿠폰 사용 TX() {
    쿠폰 사용();
}

결제 데이터 생성 TX() {
    결제 데이터 생성();
}

포인트 차감 TX() {
    포인트 차감();
}

주문 상태 변경 TX() {
    주문 상태 변경();
}
````
발생할 수 있는 문제점 </br>
* 쿠폰 사용 성공 후 결제 생성 실패 : 쿠폰은 사용됐는데 결제에서 실패하면 데이터 정합성 불일치 문제가 발생한다. 
* 결제 생성 성공 후 포인트 차감 실패 : 결제 데이터 생성 후 포인트가 차감 단계에서 실패하면 데이터 정합성 불일치 문제가 발생한다.
* 포인트 차감 성공 후 주문 상태 변경 실패 : 결제 데이터 생성과 포인트 차감은 완료 되었는데 주문 상태를 ‘결제 완료’로 변경하는 단계에서 실패하면 데이터 정합성 불일치 문제가 발생한다.

## 해결 방안
### SAGA 패턴
마이크로 서비스들끼리 이벤트를 주고 받아 특정 마이크로서 비스에서의 작업이 실패하면 이전까지의 작업이 완료된 마이크 서비스들에게 보상 트랜잭션을 실행하여 분산 환경에서 원자성을 보장하는 패턴이다. 
> 보상 트랜잭션 : 분산 환경에서 하나의 작업 흐름 중 일부 단계가 실패했을 때, 이미 완료된 이전 단계 작업을 취소하거나 되돌리는 작업

SAGA 패턴에는 Choreography, Orchestration 두 가지로 종류가 존재한다. 

### Choreography
* 중앙 제어 없이 서비스끼리 이벤트로 통신하는 방법이다.
* 서비스들은 특정 동작을 수행하면 도메인 이벤트를 발행하고, 이를 구독하고 있던 서비스가 그에 따른 트랜잭션을 수행한다.
* 이벤트는 Kafka 와 같은 메세지 큐를 이용해 비동기로 전달한다.

장점
* 참여자가 적고 중앙 제어가 필요없는 경우 적합하다
* 추가 서비스 구현이 필요없다
* 역할이 분산되어 단일 실패 지점이 존재하지 않는다
* 참여자는 서로 직접 알지 못하기 때문에 느슨한 결합이다
  
단점
* 명령 추적이 어렵기 때문에 워크플로 파악이 어렵다
* Saga 참가자 간에 순환 종속성 발생 가능하다
* 통합 테스트가 어렵다

### Orchestration
* 오케스트레이터(orchestrator) 라는 중앙 컨트롤러가 보상 작업을 트리거하는 방식이다.
* 오케스트레이터는 모든 트랜잭션을 처리하고 수행해야 하는 작업을 메세지를 보내 참여자들과 통신한다. 오케스트레이터는 작업의 상태를 저장 및 해석하고 있어서 분산 트랜잭션의 중앙 집중화가 이루어지고 데이터 일관성을 지킬 수 있다.

장점
* 참여자가 많거나 추가되는 상황 같이 복잡한 워크플로에 적합하다
* 활동 흐름의 제어 가능하다
* 오케스트레이터가 존재하여 순환 종속성이 발생되지 않는다
* 각 참여자는 다른 참여자의 명령어를 알지 않아도 된다
  
단점
* 중앙에서 관리를 위한 복잡한 로직 구현 필요하다
* 모든 워크플로를 관리하기 때문에 실패 지점이 될 수 있다

### 각 기능에 대해 SAGA 패턴 적용 비교 

### 주문 기능 `Orchestration` 방식 적용
* 슈도 코드 
```
OrderApplicationService() {
    try {
        상품 재고 차감 TX();
        주문 데이터 생성 TX();
        데이터 플랫폼 전송 TX();

        // 모든 작업 성공
        return "주문 완료";
    } catch (Exception e) {
        // 어느 단계에서든 실패하면 보상 작업 실행
        보상 작업 실행();
        return "주문 실패: " + e.getMessage();
    }
}

보상 작업 실행() {
    상품 재고 복구();
    주문 데이터 삭제();
}
```

* 장점 
  * 중앙 집권적으로 서비스 호출 순서를 제어하기 때문에 비즈니스 로직 흐름 제어가 명확하다.
  * OrderApplicationService가 orchestrator로 상태를 관리하므로, 현재 진행 상태 및 실패 위치 추적이 용이하다

* 단점
  * OrderApplicationService가 각 단계 상태 및 보상 작업을 전부 관리하므로, OrderApplicationServic가 비대해지고 복잡해질 수 있다.
  * OrderApplicationService가 각 서비스 호출 순서와 응답 상태에 직접 의존하므로, 서비스 변경 시 OrderApplicationService 로직도 변경될 가능성이 존재하여 서비스 간 결합도가 증가한다.

### 주문 기능 'Choreography' 방식 적용 
* 슈도 코드
```
// 1. 상품 재고 차감 서비스
상품 재고 차감 TX() {
    상품 조회();
    상품 재고 차감();

    // 이벤트 발행
    주문_데이터_생성_요청_이벤트_발행();
}

// 2. 주문 데이터 생성 서비스
주문 데이터 생성 TX(주문_데이터_생성_요청_이벤트 event) {
    주문 데이터 생성();

    // 이벤트 발행
    데이터_플랫폼_전송_요청_이벤트_발행();
}

// 3. 데이터 플랫폼 전송 서비스
데이터 플랫폼 전송 TX(데이터_플랫폼_전송_요청_이벤트 event) {
    데이터 플랫폼 전송();
}

// 실패 시 보상 트랜잭션 (각 서비스에서 개별 처리)
재고_복구() { 상품 재고 복구(); }
주문_데이터_삭제() { 주문 데이터 삭제(); }

```

* 장점 
  * 서비스 간 직접 호출 대신 이벤트 기반 비동기 통신으로 개별 서비스 변경이 다른 서비스에 영향 적어 서비스 간 결합도가 완화된다.
  * 새로운 서비스가 생기더라도 이벤트만 구독하면 되므로 확장성 증가한다.
  * 이벤트 발행 후 비동기로 처리되므로, 대기시간 감소 및 트래픽 분산 효과가 발생한다.
  
* 단점
  * 이벤트가 비동기 분산되어 진행되기 때문에, 전체 프로세스 흐름과 상태 파악 어렵다.
  * 어느 서비스에서 실패했는지 명확하지 않아, 보상 트랜잭션 설계 난이도 증가한다.

### 결제 기능 `Orchestration` 방식 적용
* 슈도 코드 
```
PaymentApplicationService() {
    try {
        쿠폰 사용 TX();
        결제 데이터 생성 TX();
        포인트 차감 TX();
        주문 상태 변경 TX();

        return "결제 완료";
    } catch (Exception e) {
        보상 작업 실행(e);
        return "결제 실패: " + e.getMessage();
    }
}

보상 작업 실행(Exception e) {
    if (e.getMessage().contains("주문 상태 변경 실패")) {
        포인트 복구();
        결제 데이터 삭제();
        쿠폰 복구();
    } else if (e.getMessage().contains("포인트 차감 실패")) {
        결제 데이터 삭제();
        쿠폰 복구();
    } else if (e.getMessage().contains("결제 데이터 생성 실패")) {
        쿠폰 복구();
    }
}
```

장단점은 주문 기능 `Orchestration` 방식 적용의 장단점과 동일하다. 


### 결제 기능 'Choreography' 방식 적용

```
// 1. 쿠폰 사용 서비스
쿠폰 사용 TX() {
    쿠폰 사용();

    // 이벤트 발행
    결제_데이터_생성_요청_이벤트_발행();
}

// 2. 결제 데이터 생성 서비스
결제 데이터 생성 TX(결제_데이터_생성_요청_이벤트 event) {
    결제 데이터 생성();

    // 이벤트 발행
    포인트_차감_요청_이벤트_발행();
}

// 3. 포인트 차감 서비스
포인트 차감 TX(포인트_차감_요청_이벤트 event) {
    포인트 차감();

    // 이벤트 발행
    주문_상태_변경_요청_이벤트_발행();
}

// 4. 주문 상태 변경 서비스
주문 상태 변경 TX(주문_상태_변경_요청_이벤트 event) {
    주문 상태 변경();

    // 결제 완료 이벤트 발행(필요 시)
    결제_완료_이벤트_발행();
}

// 각 서비스 보상 트랜잭션 (개별 서비스 내 보상 로직)
쿠폰_복구() { 쿠폰 복구(); }
결제_데이터_삭제() { 결제 데이터 삭제(); }
포인트_복구() { 포인트 복구(); }
주문_상태_롤백() { 주문 상태 원복(); }

```

장단점은 주문 기능 `Choreography` 방식 적용의 장단점과 동일하다.


## 결론
모놀리식 구조로 운영되던 서비스를 MSA 구조로 전환한다는 가정하에, 서비스 간 트랜잭션 처리의 한계와 해결 방안에 대해 분석해보았습니다. </br>
주문 및 결제와 같은 기능은 여러 서비스가 엮여 있어 중간에 하나라도 실패하면 데이터 불일치 문제가 발생할 수 있다는 점을 확인하였고, MSA 구조로 트랜잭션을 분리한 이후 서비스 간 데이터 정합성 유지가 가장 중요한 이슈가 되었습니다. </br>
정합성 문제를 해결하기 위해 SAGA 패턴의 Orchestration 방식과 Choreography 방식을 각각 적용해보며 장단점을 비교해보았습니다.</br>
최종적으로 어떤 방식을 선택할지는 프로젝트의 중요도, 서비스 복잡도, 운영 환경에 따라 달라질 수 있으며, 상황에 맞춰 유연하게 선택하는 접근이 필요함을 확인했습니다.</br>
결국 MSA 전환 시 서비스의 독립성을 유지하면서도 데이터 정합성을 확보할 수 있는 트랜잭션 처리 설계가 필수적임을 확인하였습니다. 

---

## 출처
* https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/
* https://dodo-devops.tistory.com/19
* https://azderica.github.io/01-architecture-msa/#google_vignette
* https://devyonghee.github.io/theory/2022/09/24/orchestration-vs-choreography/
