# MSA 구조로 전환을 위한 서비스 분리 및 트랜잭션 처리 방안 설계

----

## 서론
서비스의 규모가 확장됨에 따라 모놀리식 아키텍처에서 MSA 구조로 전환을 위해 도메인 별로 배포 단위를 분리한다면 그 분리에 따른 트랜잭션 처리의 한계와 해결 방안에 대해 고려해본다.

## 모놀리식 vs MSA
### 모놀리식 아키텍처
- 소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어 있는 형태이다.
- 모든 프로세스가 긴밀하게 결합되고 단일 서비스로 실행된다.

장점
- 소규모 프로젝트에서는 합리적이다.
- 개빌, 빌드, 배포가 용이하다.

단점 
- 애플리케이션 구동 시간이 늘어나고 빌드, 배포 시간이 길어진다.
- 많은 양의 코드가 몰려 있어 유지보수가 힘들다.
- 일부분의 오류가 전체에 영향을 미친다.

### MSA (Micro Service Architecture)
- 하나의 큰 애플리케이션을 여러 개의 작은 서비스 유닛으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처이다. 
- 각 마이크로 서비스는 상호 통신이 가능하며 이를 통해 전체 서비스를 구성한다.

장점 
- 독립적인 서비스로 배포가 빠르고 모놀리식보다 가볍다.
- 서비스별 개별 배포 가능하여 배포 시 전체 서비스의 중단이 없다. 
- 분리된 서비스로 개발할 수 있기 떄문에 서비스마다 가장 적합한 기술을 선택할 수 있다.

단점
- 서비스가 분산되어 있어 트랜잭션 관리, 장애 추적 및 테스트가 쉽지 않다.
- 서비스마다 DB가 분리되어 있어 데이터의 조회가 어렵고 데이터의 중복이 발생한다. 

## 현재 모놀리식 구조에서 도메인 간 결합된 기능
### **주문** 기능
현재의 모놀리식 구조
````
주문 TX() {
    상품_조회();
    상품_재고_차감();
    주문_생성();
    외부_플랫폼_데이터_전송();
}
````
결합된 도메인
* 상품
* 주문
* 외부 플랫폼

현재 구조에서의 문제점 : 상품 재고 차감, 주문 생성과 같은 메인 로직이 외부 데이터 플랫폼 데이터 전송과 같은 부가 로직과 하나의 트랜잭션에 묶여있어 외부 플랫폼 전송이 실패하면 전체가 롤백되는 현상이 발생한다.

### **결제** 기능
  현재의 모놀리식 구조
```
결제 TX() {
    주문_조회();
    쿠폰_사용();
    결제_생성();
    포인트_차감();
    주문_상태_변경();
}
```
결합된 도메인
* 주문
* 쿠폰
* 결제
* 포인트

## MSA로 구조로 도메인 분리
### 도메인 분리 및 담당 업무
* `유저`, `포인트` : 
  * 유저 정보를 조회한다.
  * 유저의 포인트 정보를 조회한다.
  * 유저의 포인트를 충전한다.
  * 유저의 포인트를 차감한다.
* `상품`, `재고`
  * 상품을 조회한다.
  * 상품 재고를 차감한다.
* `쿠폰`
  * 쿠폰을 발행한다.
  * 쿠폰을 사용한다.
* `주문`
  * 주문 데이터를 생성한다.
  * 외부 데이터 플랫폼에 데이터를 전송한다.
* `결제`
  * 결제 데이터를 생성한다.

## 트랜잭션을 분리할 기능 분석

<details>
<summary>트랜잭션이란?</summary>

### 트랜잭션
트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

### 트랜잭션 ACID 성질
* Atomicity (원자성)
    * 모든 작업이 하나의 단위로 실행되어야 한다.
    * 트랜잭션에 포함된 작업이 모두 성공하거나, 하나라도 실패하면 전체가 롤백되어 아무것도 실행되지 않은 상태가 되어야 한다.
* Consistency (일관성)
    * 트랜잭션이 실행된 후에도 데이터베이스의 상태가 일관성을 유지해야 한다.
* Isolation (격리성)
    * 동시에 여러 트랜잭션이 실행되더라도 각 트랜잭션은 서로 간섭받지 않고 독립적으로 실행되어야 한다.
* Durability (지속성)
    * 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 반영되어야 한다.

</details>

### 트랜잭션 분리할 기능 분석
* **주문 기능** 
````
주문 데이터 생성 TX() {
    주문 데이터 생성();
}

상품 재고 차감 TX() {
    상품 조회();
    상품 재고 차감();
}

데이터 플랫폼 전송 TX() {
    데이터 플랫폼 전송();
}
````
발생할 수 있는 문제점 </br>
재고 차감 후 주문 생성 실패 : 재고는 차감되었는데 주문이 생성되지 않아 데이터 정합성의 불일치가 발생한다.

* **결제 기능**
````
쿠폰 사용 TX() {
    쿠폰 사용();
}

결제 데이터 생성 TX() {
    결제 데이터 생성();
}

포인트 차감 TX() {
    포인트 차감();
}

주문 상태 변경 TX() {
    주문 상태 변경();
}
````
발생할 수 있는 문제점 </br>
* 쿠폰 사용 성공 후 결제 생성 실패 : 쿠폰은 사용됐는데 결제에서 실패하면 데이터 정합성 불일치 문제가 발생한다. 
* 결제 생성 성공 후 포인트 차감 실패 : 결제 데이터 생성 후 포인트가 차감 단계에서 실패하면 데이터 정합성 불일치 문제가 발생한다.
* 포인트 차감 성공 후 주문 상태 변경 실패 : 결제 데이터 생성과 포인트 차감은 완료 되었는데 주문 상태를 ‘결제 완료’로 변경하는 단계에서 실패하면 데이터 정합성 불일치 문제가 발생한다.

## 해결 방안
### SAGA 패턴
마이크로 서비스들끼리 이벤트를 주고 받아 특정 마이크로서 비스에서의 작업이 실패하면 이전까지의 작업이 완료된 마이크 서비스들에게 보상 트랜잭션을 실행하여 분산 환경에서 원자성을 보장하는 패턴이다. 
> 보상 트랜잭션 : 분산 환경에서 하나의 작업 흐름 중 일부 단계가 실패했을 때, 이미 완료된 이전 단계 작업을 취소하거나 되돌리는 작업

SAGA 패턴에는 Choreography, Orchestration 두 가지로 종류가 있다. 

### Choreography
* 중앙 제어 없이 서비스끼리 이벤트로 통신하는 방법이다.
* 서비스들은 특정 동작을 수행하면 도메인 이벤트를 발행하고, 이를 구독하고 있던 서비스가 그에 따른 트랜잭션을 수행한다.
* 이벤트는 Kafka 와 같은 메세지 큐를 이용해 비동기로 전달한다.

장점
* 참여자가 적고 중앙 제어가 필요없는 경우 적합하다
* 추가 서비스 구현이 필요없다
* 역할이 분산되어 단일 실패 지점이 존재하지 않는다
* 참여자는 서로 직접 알지 못하기 때문에 느슨한 결합이다
단점
* 명령 추적이 어렵기 때문에 워크플로 파악이 어렵다
* Saga 참가자 간에 순환 종속성 발생 가능하다
* 통합 테스트가 어렵다

### Orchestration
* 오케스트레이터(orchestrator) 라는 중앙 컨트롤러가 보상 작업을 트리거하는 방식이다.
* 오케스트레이터는 모든 트랜잭션을 처리하고 수행해야 하는 작업을 메세지를 보내 참여자들과 통신한다. 오케스트레이터는 작업의 상태를 저장 및 해석하고 있어서 분산 트랜잭션의 중앙 집중화가 이루어지고 데이터 일관성을 지킬 수 있다.

장점
* 참여자가 많거나 추가되는 상황 같이 복잡한 워크플로에 적합하다
* 활동 흐름의 제어 가능하다
* 오케스트레이터가 존재하여 순환 종속성이 발생되지 않는다
* 각 참여자는 다른 참여자의 명령어를 알지 않아도 된다
단점
* 중앙에서 관리를 위한 복잡한 로직 구현 필요하다
* 모든 워크플로를 관리하기 때문에 실패 지점이 될 수 있다

### 각 기능에 대한 해결 방안 정리 

### 주문 기능 `Orchestration` 방식 적용 
선정 이유
* 재고 차감 실패 시 주문 취소가 명확히 필요하다.
→ 오케스트레이터가 흐름을 직접 제어하면서 재고 차감 실패 시 주문 생성 취소(보상 트랜잭션) 처리하기 쉽다.
* 재고 차감, 주문 생성 순서가 중요하다.
→ Orchestration은 흐름이 중앙에서 명령형으로 제어되므로 성공/실패에 따라 다음 단계 명확히 처리할 수 있다.
* 데이터 플랫폼 전송은 비동기 전송이 많다.
→ Orchestration에서 주문 생성과 재고 차감 성공 이후 이벤트 발행 방식(Outbox 패턴) 으로 비동기 전송 처리하기 용이하다.

Orchestration 적용 흐름
1. 주문 생성 성공
2. 재고 차감 성공 → 다음 단계 진행
3. 재고 차감 실패 → 주문 취소 명령 실행 (보상 트랜잭션)
4. 주문, 재고 완료 후 Outbox 패턴으로 데이터 플랫폼 전송

### 결제 기능 `Orchestration` 방식 적용
선정 이유
* 단계별로 실패 시 보상 트랜잭션 반드시 필요하다.
→ 쿠폰 사용 취소, 결제 취소, 포인트 복구와 같이 각 단계마다 보상 로직이 명확해야 한다.
* → Orchestration에서는 결제 서비스(오케스트레이터)가 단계별 성공/실패에 맞춰 즉각 보상 트랜잭션 실행하기 용이하다.
* 결제 로직은 성공 여부가 매우 중요하다.
→ 결제 금액, 쿠폰 적용, 포인트 사용 등 하나라도 꼬이면 치명적이므로 흐름 제어와 오류 복구가 명확해야 한다.
* 복잡한 보상 트랜잭션
→ 결제는 단순 취소가 아닌 포인트 복구, 쿠폰 복구 등 다단계 보상이 필요할 수 있다.
→ Orchestration 방식이 이런 복합 보상 처리에 적합하다.

### Choreography가 적합하지 않다고 생각한 이유 
* 주문과 결제 기능 모두 성공/실패 흐름이 복잡하고 실패 시 보상 트랜잭션이 핵심이다.
* Choreography 방식은 이벤트 기반이라 실패 보상 흐름이 꼬일 가능성이 존재한다.
* 성공/실패 상황에 따라 다음 단계로 넘어가야 하는 흐름이 많으면 Orchestration이 더 명확하고 안정적이라고 판단했습니다. 

## 결론
모놀리식 구조로 운영되던 서비스를 MSA 구조로 전환한다는 가정하에, 서비스 간 트랜잭션 처리의 한계와 해결 방안에 대해 분석해보았습니다. 
분석 결과, 주문 및 결제와 같은 기능은 여러 서비스가 엮여 있어 중간에 하나라도 실패하면 데이터 불일치 문제가 발생할 수 있다는 점을 확인하였고,
재고, 주문, 결제와 같은 도메인은 데이터의 정합성이 매우 중요하다 생각되어 정합성이 엄격하게 관리될 수 있는 SAGA 패턴 중 Orchestration 방식을 적용하는 것이 적합하다고 판단하였습니다.
결국 MSA 전환 시 서비스의 독립성을 유지하면서도 데이터 정합성을 확보할 수 있는 트랜잭션 처리 설계가 필수적임을 확인하였습니다. 

---

출처
* https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/
* https://dodo-devops.tistory.com/19
* https://azderica.github.io/01-architecture-msa/#google_vignette
* https://devyonghee.github.io/theory/2022/09/24/orchestration-vs-choreography/