# chapter2 이커머스 서버 구축 3주 과정 회고
chapter1 TDD & 클린 아키텍처 1, 2 주차보다 난이도가 확 높아져 많이 헤메기도 했지만 많은걸 배울 수 있었고 아직 많이 모자르다는것을 느껴 더더욱 열심히 해야겠다는 생각이 들었다.

## 주차 별 진행 내용 & 배운 점
###  3주차 진행 내용
3주차는 주어진 시나리오를 보고 설계 작업을 했다. 요구사항을 분석하여 ERD, 플로우 차트, 시퀀스 다이어그램을 작성하고, chapter1 에서 배운 클린-레이어드 아키텍처를 기반으로 하여 패키지 설계를 하였다.

<b>배운 점</b></br>
* 테이블을 의도적으로 비정규화하면 쓰기 부하를 늘리고, 읽기 부하가 줄어 성능을 최적화할 수 있다. 실제 애플리케이션에서는 쓰기 작업보다 읽기 작업이 훨씬 빈번하게 수행되기 떄문이다. 또한, 동시에 스냅샷을 활용하는 이점도 함께 얻을 수 있다.
* 연산이 비번하게 수행되는 컬럼은 별도의 테이블로 분리하는 것이 좋다.  락 경합을 줄이고, 불필요한 연산을 줄여 성능이 최적화된다.

### 4주차 진행 내용
4주차는 3주차에 설계한 걸 바탕으로 본격적으로 서버를 구현하는 단계였다. 쿠폰, 주문, 결제, 포인트 등 다양한 도메인에 대한 요구사항을 구현했다.  
다양한 도메인을 클린-레이어드 아키텍처 기반으로 패키징하여 애플리케이션 계층에서 파사드 패턴으로 조합하여 구현하였다.

<b>배운 점</b></br>
* 클린-레이어드 아키텍처에서 <b>상위 계층은 하위 계층을 참조 가능하지만, 하위 계층은 상위 계층을 참조하면 안된다.</b> (상위 Interfaces → Application → Domain → Infrastructure 하위)
    * 하위 계층의 상위 계층 참조를 금지하면 비지니스 로직을 보호할 수 있다. 비지니스 로직이 있는 도메인 계층이 상위 계층을 참조하면, 상위 계층의 변경이 일어났을 때, 도메인 코드까지 수정이 필요하게 될 수도 있다. 도메인 계층이 외부를 모르도록하여 비지니스 로직이 외부 변화에 영향을 덜 받도록 하여 안정성을 높일 수 있다.
    * 의존성 역전 원칙(DIP)를 적용할 수 있다. 도메인 계층에서 Repository 인터페이스를 정의하고, 구현체는 Infrastructure 계층에서 제공한다. 이렇게 하면, 도메인 계층은 DB 기술이 변경되더라도 무관하게 유지될 수 있다.
* 애플리케이션 계층에서 파사드 패턴으로 도메인 서비스를 조합하서 사용한다.
    * 도메인 서비스가 관련된 도메인의 레포지토리만 주입받고, 애플리케이션에서 조합하여 사용하면 도메인의 응집력은 향상되면서 결합도는 낮아지고, 유지보수가 쉬우며 테스트, 트랜잭션 괸리가 유연해진다.

### 5주차 진행 내용
5주차 진행 내용은 아래와 같다.
* 글로벌 에러 핸들러 통해 예외 로깅 및, 응답 처리 핸들러 구현
* Filter, Interceptor 활용해 기능의 관점 분리하여 개선
* 모든 API가 정상적으로 동작하도록 완성하기
* 동시성 통합 테스트 진행하기

<b>배운 점</b></br>
* Filter는 Spring 컨텍스트 외부에서 동작하며, 요청과 응답을 모두 확인할 수 있기 때문에 로깅에 적합하다.
* Interceptor는 Spring 컨텍스트 내부에서 동작하며, 비즈니스 로직 실행 전후로 검증이나 보강하는 역할을 수행한다.
* Filter와 Interceptor는 최대한 작게, 역할에 맞게 개발하여 chaining 하여 사용한다.
* 비지니스 로직을 처리하다 발생하는 비지니스 에러는 도메인 패키지 안에 둔다.

## 느낀 점
이번 3주를 진행하면서 JPA도 처음 사용해보고 클린-아키텍처, 파사드 패턴을 모두 처음 적용하여 개발을 해봐서 고민하는데 시간을 많이 소요한 것 같다. 특히 4주차에 배운 점에 작성한 내용들을 사실 5주차 시작할 때 헷갈렸던 개념들이 갑자기 정리되고, 어느정도 이해가 되기 시작해 4주차의 코드들을 싹 리팩토링 하느라 시간이 부족했다. 제일 중요한 테스트 코드를 많이 작성하지 못해서 아쉬웠다. 이 부분은 빠른 시일 내에 보충해서 프로젝트의 완성도를 높일 예정이다. 
  
